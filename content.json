{"meta":{"title":"yilia","subtitle":null,"description":null,"author":"Andykpa","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"随笔/线段树","date":"2018-03-15T16:08:12.033Z","updated":"2018-03-15T09:25:48.339Z","comments":true,"path":"2018/03/16/随笔/线段树/","link":"","permalink":"http://yoursite.com/2018/03/16/随笔/线段树/","excerpt":"","text":"#定义 以递归实现1234#define maxn 100007 //元素总个数 #define ls l,m,rt&lt;&lt;1 #define rs m+1,r,rt&lt;&lt;1|1 int Sum[maxn&lt;&lt;2],Add[maxn&lt;&lt;2];//Sum求和，Add为懒惰标记 int A[maxn],n;//存原数组数据下标[1,n] #建树123456789101112131415//PsuhUp函数更新节点的信息，这里是求和void PushUp(int rt)&#123; Sum[rt]=Sum[rt&lt;&lt;1]+Sum[rt&lt;&lt;1|1];//Build建树void Build(int l,int r,int rt)&#123; if(l==r)&#123;//若到达叶节点 Sum[rt]=A[l]; return ; &#125; int m=(l+r)&gt;&gt;1; //左右递归 Build(l,m,rt&lt;&lt;1); Build(m+1,r,rt&lt;&lt;1|1); PushUp(rt); &#125; #点修改：假设A[L]+=C123456789101112void Update(int L,int C,int l,int r,int rt)&#123;//l,r表示当前节点区间，rt表示当前节点编号 if(l==r)&#123;//到叶节点，修改 Sum[rt]+=C; return; &#125; int m=(l+r)&gt;&gt;1; //根据条件判断往左子树调用还是往右 if(L &lt;= m) Update(L,C,l,m,rt&lt;&lt;1); else Update(L,C,m+1,r,rt&lt;&lt;1|1); PushUp(rt);//子节点更新了，所以本节点也需要更新信息 &#125; #区间修改： 假设A[L,R]+=C1234567891011121314void Update(int L,int R,int C,int l,int r,int rt)&#123;//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 if(L &lt;= l &amp;&amp; r &lt;= R)&#123;//如果本区间完全在操作区间[L,R]以内 Sum[rt]+=C*(r-l+1);//更新数字和，向上保持正确 Add[rt]+=C;//增加Add标记，表示本区间的Sum正确，子区间的Sum仍需要根据Add的值来调整 return ; &#125; int m=(l+r)&gt;&gt;1; PushDown(rt,m-l+1,r-m);//下推标记 //这里判断左右子树跟[L,R]有无交集，有交集才递归 if(L &lt;= m) Update(L,R,C,l,m,rt&lt;&lt;1); if(R &gt; m) Update(L,R,C,m+1,r,rt&lt;&lt;1|1); PushUp(rt);//更新本节点信息 &#125; 这里简单介绍一下什么是懒惰标记(add数组） 节点的统计信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。也可以说，懒标记的作用是记录每次、每个节点要更新的值，也就是delta,但线段树的优点不在于全记录（因为慢），而在于传递式记录：整个区间都被操作，记录在公共祖先节点上；只修改了一部分，那么就记录在这部分的公共祖先上；如果四环以内只修改了自己的话，那就只改变自己。 正如上面所描述的如果要给区间所有的值都加上1，那么，实际上并没有给这个区间的所有值都加上1，而是打上一个标记记下来。打上标记后再根据此节点进行更新节点信息，这就是向下延迟修改，但是向上显示的是修改后的信息，所以查询的时候就是的得到的正确结果。也可以简单的说将他要修改节点的行为记录下来，但并不修改，当我要用到这个节点（查询这个节点）时，再进行修改有的标记之间会相互影响，所以比较简单的做法是，每递归到一个区间，首先下推标记（若本节点有标记，就下推标记），然后再打上新的标记，这样仍然每个区间操作的复杂度是O(log2(n))。 #区间查询：询问A[L,R]的和首先是下推标记的函数：1234567891011121314void PushDown(int rt,int ln,int rn)&#123; //ln,rn为左子树，右子树的数字数量。 if(Add[rt])&#123; //下推标记 Add[rt&lt;&lt;1]+=Add[rt]; Add[rt&lt;&lt;1|1]+=Add[rt]; //修改子节点的Sum使之与对应的Add相对应 Sum[rt&lt;&lt;1]+=Add[rt]*ln; Sum[rt&lt;&lt;1|1]+=Add[rt]*rn; //清除本节点标记 Add[rt]=0; &#125; &#125; #然后是区间查询的函数：12345678910111213141516int Query(int L,int R,int l,int r,int rt)&#123;//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 if(L &lt;= l &amp;&amp; r &lt;= R)&#123; //在区间内，直接返回 return Sum[rt]; &#125; int m=(l+r)&gt;&gt;1; //下推标记，否则Sum可能不正确 PushDown(rt,m-l+1,r-m); //累计答案 int ANS=0; if(L &lt;= m) ANS+=Query(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) ANS+=Query(L,R,m+1,r,rt&lt;&lt;1|1); return ANS; &#125; #函数调用: 12345678//建树 Build(1,n,1); //点修改 Update(L,C,1,n,1); //区间修改 Update(L,R,C,1,n,1); //区间查询 int ANS=Query(L,R,1,n,1); #####by markdown参考博客","categories":[],"tags":[]},{"title":"","slug":"线段树","date":"2018-03-15T15:32:33.416Z","updated":"2018-03-15T09:25:48.339Z","comments":true,"path":"2018/03/15/线段树/","link":"","permalink":"http://yoursite.com/2018/03/15/线段树/","excerpt":"","text":"#定义 以递归实现1234#define maxn 100007 //元素总个数 #define ls l,m,rt&lt;&lt;1 #define rs m+1,r,rt&lt;&lt;1|1 int Sum[maxn&lt;&lt;2],Add[maxn&lt;&lt;2];//Sum求和，Add为懒惰标记 int A[maxn],n;//存原数组数据下标[1,n] #建树123456789101112131415//PsuhUp函数更新节点的信息，这里是求和void PushUp(int rt)&#123; Sum[rt]=Sum[rt&lt;&lt;1]+Sum[rt&lt;&lt;1|1];//Build建树void Build(int l,int r,int rt)&#123; if(l==r)&#123;//若到达叶节点 Sum[rt]=A[l]; return ; &#125; int m=(l+r)&gt;&gt;1; //左右递归 Build(l,m,rt&lt;&lt;1); Build(m+1,r,rt&lt;&lt;1|1); PushUp(rt); &#125; #点修改：假设A[L]+=C123456789101112void Update(int L,int C,int l,int r,int rt)&#123;//l,r表示当前节点区间，rt表示当前节点编号 if(l==r)&#123;//到叶节点，修改 Sum[rt]+=C; return; &#125; int m=(l+r)&gt;&gt;1; //根据条件判断往左子树调用还是往右 if(L &lt;= m) Update(L,C,l,m,rt&lt;&lt;1); else Update(L,C,m+1,r,rt&lt;&lt;1|1); PushUp(rt);//子节点更新了，所以本节点也需要更新信息 &#125; #区间修改： 假设A[L,R]+=C1234567891011121314void Update(int L,int R,int C,int l,int r,int rt)&#123;//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 if(L &lt;= l &amp;&amp; r &lt;= R)&#123;//如果本区间完全在操作区间[L,R]以内 Sum[rt]+=C*(r-l+1);//更新数字和，向上保持正确 Add[rt]+=C;//增加Add标记，表示本区间的Sum正确，子区间的Sum仍需要根据Add的值来调整 return ; &#125; int m=(l+r)&gt;&gt;1; PushDown(rt,m-l+1,r-m);//下推标记 //这里判断左右子树跟[L,R]有无交集，有交集才递归 if(L &lt;= m) Update(L,R,C,l,m,rt&lt;&lt;1); if(R &gt; m) Update(L,R,C,m+1,r,rt&lt;&lt;1|1); PushUp(rt);//更新本节点信息 &#125; 这里简单介绍一下什么是懒惰标记(add数组） 节点的统计信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。也可以说，懒标记的作用是记录每次、每个节点要更新的值，也就是delta,但线段树的优点不在于全记录（因为慢），而在于传递式记录：整个区间都被操作，记录在公共祖先节点上；只修改了一部分，那么就记录在这部分的公共祖先上；如果四环以内只修改了自己的话，那就只改变自己。 正如上面所描述的如果要给区间所有的值都加上1，那么，实际上并没有给这个区间的所有值都加上1，而是打上一个标记记下来。打上标记后再根据此节点进行更新节点信息，这就是向下延迟修改，但是向上显示的是修改后的信息，所以查询的时候就是的得到的正确结果。也可以简单的说将他要修改节点的行为记录下来，但并不修改，当我要用到这个节点（查询这个节点）时，再进行修改有的标记之间会相互影响，所以比较简单的做法是，每递归到一个区间，首先下推标记（若本节点有标记，就下推标记），然后再打上新的标记，这样仍然每个区间操作的复杂度是O(log2(n))。 #区间查询：询问A[L,R]的和首先是下推标记的函数：1234567891011121314void PushDown(int rt,int ln,int rn)&#123; //ln,rn为左子树，右子树的数字数量。 if(Add[rt])&#123; //下推标记 Add[rt&lt;&lt;1]+=Add[rt]; Add[rt&lt;&lt;1|1]+=Add[rt]; //修改子节点的Sum使之与对应的Add相对应 Sum[rt&lt;&lt;1]+=Add[rt]*ln; Sum[rt&lt;&lt;1|1]+=Add[rt]*rn; //清除本节点标记 Add[rt]=0; &#125; &#125; #然后是区间查询的函数：12345678910111213141516int Query(int L,int R,int l,int r,int rt)&#123;//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 if(L &lt;= l &amp;&amp; r &lt;= R)&#123; //在区间内，直接返回 return Sum[rt]; &#125; int m=(l+r)&gt;&gt;1; //下推标记，否则Sum可能不正确 PushDown(rt,m-l+1,r-m); //累计答案 int ANS=0; if(L &lt;= m) ANS+=Query(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) ANS+=Query(L,R,m+1,r,rt&lt;&lt;1|1); return ANS; &#125; #函数调用: 12345678//建树 Build(1,n,1); //点修改 Update(L,C,1,n,1); //区间修改 Update(L,R,C,1,n,1); //区间查询 int ANS=Query(L,R,1,n,1); #####by markdown参考博客","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-15T14:37:22.572Z","updated":"2018-03-15T14:37:22.573Z","comments":true,"path":"2018/03/15/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}